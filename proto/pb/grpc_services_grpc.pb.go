// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	// Docs for this Create User endpoint
	//
	// Create User Service. This service will recieve
	// an `User` entitie as request argument and will return
	// only the `UserID` that had been created if everything went well
	SignUp(ctx context.Context, in *User, opts ...grpc.CallOption) (*UserID, error)
	// Docs for GetAllUsers endpoint
	//
	// This function will recieve an empty request field and will return a
	// list with all the registered users, without their passwords
	GetAllUsers(ctx context.Context, in *GetEmptyRequest, opts ...grpc.CallOption) (*GetAllUsersResponse, error)
	// Docs for this GetUserById endpoint
	//
	// This function will recieve an UserID as argument to the request
	// and will return as payload the user referred to that id, without
	// his password
	GetUserById(ctx context.Context, in *UserID, opts ...grpc.CallOption) (*UserWithoutPassword, error)
	// Docs for this DeleteUser endopoint
	//
	// This function will recieve an userID as argumento the the request
	// and will return as payload the user referred to that id, without
	// his password
	DeleteUser(ctx context.Context, in *UserID, opts ...grpc.CallOption) (*UserWithoutPassword, error)
	// Docs for the UpdateUser endpoint
	//
	// This function will recieve an UserWithoutPassword as argumento the the request
	// and will return as payload the user referred, without
	// his password
	UpdateUser(ctx context.Context, in *UserWithoutPassword, opts ...grpc.CallOption) (*UserWithoutPassword, error)
	// Docs for the Login endpoint
	//
	// This is the login service, that will recieve a login request with the email and password fields
	// and check if satisfies all conditions to generate a JWT Token
	SignIn(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) SignUp(ctx context.Context, in *User, opts ...grpc.CallOption) (*UserID, error) {
	out := new(UserID)
	err := c.cc.Invoke(ctx, "/apiservice.UserService/SignUp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetAllUsers(ctx context.Context, in *GetEmptyRequest, opts ...grpc.CallOption) (*GetAllUsersResponse, error) {
	out := new(GetAllUsersResponse)
	err := c.cc.Invoke(ctx, "/apiservice.UserService/GetAllUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserById(ctx context.Context, in *UserID, opts ...grpc.CallOption) (*UserWithoutPassword, error) {
	out := new(UserWithoutPassword)
	err := c.cc.Invoke(ctx, "/apiservice.UserService/GetUserById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DeleteUser(ctx context.Context, in *UserID, opts ...grpc.CallOption) (*UserWithoutPassword, error) {
	out := new(UserWithoutPassword)
	err := c.cc.Invoke(ctx, "/apiservice.UserService/DeleteUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateUser(ctx context.Context, in *UserWithoutPassword, opts ...grpc.CallOption) (*UserWithoutPassword, error) {
	out := new(UserWithoutPassword)
	err := c.cc.Invoke(ctx, "/apiservice.UserService/UpdateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) SignIn(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, "/apiservice.UserService/SignIn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility
type UserServiceServer interface {
	// Docs for this Create User endpoint
	//
	// Create User Service. This service will recieve
	// an `User` entitie as request argument and will return
	// only the `UserID` that had been created if everything went well
	SignUp(context.Context, *User) (*UserID, error)
	// Docs for GetAllUsers endpoint
	//
	// This function will recieve an empty request field and will return a
	// list with all the registered users, without their passwords
	GetAllUsers(context.Context, *GetEmptyRequest) (*GetAllUsersResponse, error)
	// Docs for this GetUserById endpoint
	//
	// This function will recieve an UserID as argument to the request
	// and will return as payload the user referred to that id, without
	// his password
	GetUserById(context.Context, *UserID) (*UserWithoutPassword, error)
	// Docs for this DeleteUser endopoint
	//
	// This function will recieve an userID as argumento the the request
	// and will return as payload the user referred to that id, without
	// his password
	DeleteUser(context.Context, *UserID) (*UserWithoutPassword, error)
	// Docs for the UpdateUser endpoint
	//
	// This function will recieve an UserWithoutPassword as argumento the the request
	// and will return as payload the user referred, without
	// his password
	UpdateUser(context.Context, *UserWithoutPassword) (*UserWithoutPassword, error)
	// Docs for the Login endpoint
	//
	// This is the login service, that will recieve a login request with the email and password fields
	// and check if satisfies all conditions to generate a JWT Token
	SignIn(context.Context, *LoginRequest) (*LoginResponse, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserServiceServer struct {
}

func (UnimplementedUserServiceServer) SignUp(context.Context, *User) (*UserID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignUp not implemented")
}
func (UnimplementedUserServiceServer) GetAllUsers(context.Context, *GetEmptyRequest) (*GetAllUsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllUsers not implemented")
}
func (UnimplementedUserServiceServer) GetUserById(context.Context, *UserID) (*UserWithoutPassword, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserById not implemented")
}
func (UnimplementedUserServiceServer) DeleteUser(context.Context, *UserID) (*UserWithoutPassword, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUserServiceServer) UpdateUser(context.Context, *UserWithoutPassword) (*UserWithoutPassword, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedUserServiceServer) SignIn(context.Context, *LoginRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignIn not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_SignUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).SignUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiservice.UserService/SignUp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).SignUp(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetAllUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetAllUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiservice.UserService/GetAllUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetAllUsers(ctx, req.(*GetEmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiservice.UserService/GetUserById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserById(ctx, req.(*UserID))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiservice.UserService/DeleteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DeleteUser(ctx, req.(*UserID))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserWithoutPassword)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiservice.UserService/UpdateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateUser(ctx, req.(*UserWithoutPassword))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_SignIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).SignIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiservice.UserService/SignIn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).SignIn(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "apiservice.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SignUp",
			Handler:    _UserService_SignUp_Handler,
		},
		{
			MethodName: "GetAllUsers",
			Handler:    _UserService_GetAllUsers_Handler,
		},
		{
			MethodName: "GetUserById",
			Handler:    _UserService_GetUserById_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _UserService_DeleteUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _UserService_UpdateUser_Handler,
		},
		{
			MethodName: "SignIn",
			Handler:    _UserService_SignIn_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc_services.proto",
}

// DogServiceClient is the client API for DogService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DogServiceClient interface {
	// Create Dog Service
	//
	// Create Dog Service will recieve a CreateDogRequest message as argument and will return a dog object
	CreateDog(ctx context.Context, in *CreateDogRequest, opts ...grpc.CallOption) (*Dog, error)
	// Get All Dog Service
	//
	// Get All Dog will recieve an empty request message as argument and will return a list of dog object
	GetAllDogs(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*GetAllDogsResponse, error)
	// Get Dog By Id Service
	//
	// Get Dog By Id Service will recieve an ID message as argument and will return a dog that correspond to the given ID
	GetDogById(ctx context.Context, in *DogID, opts ...grpc.CallOption) (*Dog, error)
	// Delete Dog Service
	//
	// Delete Dog Service will recieve an ID message as argument and will return a dog that correspond to the given ID
	DeleteDog(ctx context.Context, in *DogID, opts ...grpc.CallOption) (*Dog, error)
	// Update Dog Service
	//
	// Update Dog Service will recieve an Update Dog Request message as argument and will return a updated dog object
	UpdateDog(ctx context.Context, in *UpdateDogRequest, opts ...grpc.CallOption) (*Dog, error)
}

type dogServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDogServiceClient(cc grpc.ClientConnInterface) DogServiceClient {
	return &dogServiceClient{cc}
}

func (c *dogServiceClient) CreateDog(ctx context.Context, in *CreateDogRequest, opts ...grpc.CallOption) (*Dog, error) {
	out := new(Dog)
	err := c.cc.Invoke(ctx, "/apiservice.DogService/CreateDog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dogServiceClient) GetAllDogs(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*GetAllDogsResponse, error) {
	out := new(GetAllDogsResponse)
	err := c.cc.Invoke(ctx, "/apiservice.DogService/GetAllDogs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dogServiceClient) GetDogById(ctx context.Context, in *DogID, opts ...grpc.CallOption) (*Dog, error) {
	out := new(Dog)
	err := c.cc.Invoke(ctx, "/apiservice.DogService/GetDogById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dogServiceClient) DeleteDog(ctx context.Context, in *DogID, opts ...grpc.CallOption) (*Dog, error) {
	out := new(Dog)
	err := c.cc.Invoke(ctx, "/apiservice.DogService/DeleteDog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dogServiceClient) UpdateDog(ctx context.Context, in *UpdateDogRequest, opts ...grpc.CallOption) (*Dog, error) {
	out := new(Dog)
	err := c.cc.Invoke(ctx, "/apiservice.DogService/UpdateDog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DogServiceServer is the server API for DogService service.
// All implementations must embed UnimplementedDogServiceServer
// for forward compatibility
type DogServiceServer interface {
	// Create Dog Service
	//
	// Create Dog Service will recieve a CreateDogRequest message as argument and will return a dog object
	CreateDog(context.Context, *CreateDogRequest) (*Dog, error)
	// Get All Dog Service
	//
	// Get All Dog will recieve an empty request message as argument and will return a list of dog object
	GetAllDogs(context.Context, *EmptyRequest) (*GetAllDogsResponse, error)
	// Get Dog By Id Service
	//
	// Get Dog By Id Service will recieve an ID message as argument and will return a dog that correspond to the given ID
	GetDogById(context.Context, *DogID) (*Dog, error)
	// Delete Dog Service
	//
	// Delete Dog Service will recieve an ID message as argument and will return a dog that correspond to the given ID
	DeleteDog(context.Context, *DogID) (*Dog, error)
	// Update Dog Service
	//
	// Update Dog Service will recieve an Update Dog Request message as argument and will return a updated dog object
	UpdateDog(context.Context, *UpdateDogRequest) (*Dog, error)
	mustEmbedUnimplementedDogServiceServer()
}

// UnimplementedDogServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDogServiceServer struct {
}

func (UnimplementedDogServiceServer) CreateDog(context.Context, *CreateDogRequest) (*Dog, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDog not implemented")
}
func (UnimplementedDogServiceServer) GetAllDogs(context.Context, *EmptyRequest) (*GetAllDogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllDogs not implemented")
}
func (UnimplementedDogServiceServer) GetDogById(context.Context, *DogID) (*Dog, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDogById not implemented")
}
func (UnimplementedDogServiceServer) DeleteDog(context.Context, *DogID) (*Dog, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDog not implemented")
}
func (UnimplementedDogServiceServer) UpdateDog(context.Context, *UpdateDogRequest) (*Dog, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDog not implemented")
}
func (UnimplementedDogServiceServer) mustEmbedUnimplementedDogServiceServer() {}

// UnsafeDogServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DogServiceServer will
// result in compilation errors.
type UnsafeDogServiceServer interface {
	mustEmbedUnimplementedDogServiceServer()
}

func RegisterDogServiceServer(s grpc.ServiceRegistrar, srv DogServiceServer) {
	s.RegisterService(&DogService_ServiceDesc, srv)
}

func _DogService_CreateDog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DogServiceServer).CreateDog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiservice.DogService/CreateDog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DogServiceServer).CreateDog(ctx, req.(*CreateDogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DogService_GetAllDogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DogServiceServer).GetAllDogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiservice.DogService/GetAllDogs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DogServiceServer).GetAllDogs(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DogService_GetDogById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DogID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DogServiceServer).GetDogById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiservice.DogService/GetDogById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DogServiceServer).GetDogById(ctx, req.(*DogID))
	}
	return interceptor(ctx, in, info, handler)
}

func _DogService_DeleteDog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DogID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DogServiceServer).DeleteDog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiservice.DogService/DeleteDog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DogServiceServer).DeleteDog(ctx, req.(*DogID))
	}
	return interceptor(ctx, in, info, handler)
}

func _DogService_UpdateDog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DogServiceServer).UpdateDog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiservice.DogService/UpdateDog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DogServiceServer).UpdateDog(ctx, req.(*UpdateDogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DogService_ServiceDesc is the grpc.ServiceDesc for DogService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DogService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "apiservice.DogService",
	HandlerType: (*DogServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateDog",
			Handler:    _DogService_CreateDog_Handler,
		},
		{
			MethodName: "GetAllDogs",
			Handler:    _DogService_GetAllDogs_Handler,
		},
		{
			MethodName: "GetDogById",
			Handler:    _DogService_GetDogById_Handler,
		},
		{
			MethodName: "DeleteDog",
			Handler:    _DogService_DeleteDog_Handler,
		},
		{
			MethodName: "UpdateDog",
			Handler:    _DogService_UpdateDog_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc_services.proto",
}

// KennelServiceClient is the client API for KennelService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KennelServiceClient interface {
	// Get All Kennels Service
	//
	// This service will return a list with all the registered kennels, and will recieve as input an empty request
	GetAllKennels(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*GetAllKennelsResponse, error)
	// Get Kennel By Id Service
	//
	// This service will return a specific kennel based on the given ID send it in the request
	GetKennelById(ctx context.Context, in *KennelID, opts ...grpc.CallOption) (*GetKennelByIdResponse, error)
	// Create Kennel Service
	//
	// This service will recieve a CreateKennelRequest object and will store and return a Kennel object on system
	CreateKennel(ctx context.Context, in *CreateKennelRequest, opts ...grpc.CallOption) (*Kennel, error)
	// Delete Kennel Service
	//
	// This service will recieve a KennelID and delete a kennel based on it, and will return the deleted kennel
	DeleteKennel(ctx context.Context, in *KennelID, opts ...grpc.CallOption) (*Kennel, error)
	// Update Kennel Service
	//
	// This service will recieve a Kennel object and will update the kennel based on the ID, and will return the updated kennel
	UpdateKennel(ctx context.Context, in *Kennel, opts ...grpc.CallOption) (*Kennel, error)
}

type kennelServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewKennelServiceClient(cc grpc.ClientConnInterface) KennelServiceClient {
	return &kennelServiceClient{cc}
}

func (c *kennelServiceClient) GetAllKennels(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*GetAllKennelsResponse, error) {
	out := new(GetAllKennelsResponse)
	err := c.cc.Invoke(ctx, "/apiservice.KennelService/GetAllKennels", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kennelServiceClient) GetKennelById(ctx context.Context, in *KennelID, opts ...grpc.CallOption) (*GetKennelByIdResponse, error) {
	out := new(GetKennelByIdResponse)
	err := c.cc.Invoke(ctx, "/apiservice.KennelService/GetKennelById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kennelServiceClient) CreateKennel(ctx context.Context, in *CreateKennelRequest, opts ...grpc.CallOption) (*Kennel, error) {
	out := new(Kennel)
	err := c.cc.Invoke(ctx, "/apiservice.KennelService/CreateKennel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kennelServiceClient) DeleteKennel(ctx context.Context, in *KennelID, opts ...grpc.CallOption) (*Kennel, error) {
	out := new(Kennel)
	err := c.cc.Invoke(ctx, "/apiservice.KennelService/DeleteKennel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kennelServiceClient) UpdateKennel(ctx context.Context, in *Kennel, opts ...grpc.CallOption) (*Kennel, error) {
	out := new(Kennel)
	err := c.cc.Invoke(ctx, "/apiservice.KennelService/UpdateKennel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KennelServiceServer is the server API for KennelService service.
// All implementations must embed UnimplementedKennelServiceServer
// for forward compatibility
type KennelServiceServer interface {
	// Get All Kennels Service
	//
	// This service will return a list with all the registered kennels, and will recieve as input an empty request
	GetAllKennels(context.Context, *EmptyRequest) (*GetAllKennelsResponse, error)
	// Get Kennel By Id Service
	//
	// This service will return a specific kennel based on the given ID send it in the request
	GetKennelById(context.Context, *KennelID) (*GetKennelByIdResponse, error)
	// Create Kennel Service
	//
	// This service will recieve a CreateKennelRequest object and will store and return a Kennel object on system
	CreateKennel(context.Context, *CreateKennelRequest) (*Kennel, error)
	// Delete Kennel Service
	//
	// This service will recieve a KennelID and delete a kennel based on it, and will return the deleted kennel
	DeleteKennel(context.Context, *KennelID) (*Kennel, error)
	// Update Kennel Service
	//
	// This service will recieve a Kennel object and will update the kennel based on the ID, and will return the updated kennel
	UpdateKennel(context.Context, *Kennel) (*Kennel, error)
	mustEmbedUnimplementedKennelServiceServer()
}

// UnimplementedKennelServiceServer must be embedded to have forward compatible implementations.
type UnimplementedKennelServiceServer struct {
}

func (UnimplementedKennelServiceServer) GetAllKennels(context.Context, *EmptyRequest) (*GetAllKennelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllKennels not implemented")
}
func (UnimplementedKennelServiceServer) GetKennelById(context.Context, *KennelID) (*GetKennelByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKennelById not implemented")
}
func (UnimplementedKennelServiceServer) CreateKennel(context.Context, *CreateKennelRequest) (*Kennel, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateKennel not implemented")
}
func (UnimplementedKennelServiceServer) DeleteKennel(context.Context, *KennelID) (*Kennel, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteKennel not implemented")
}
func (UnimplementedKennelServiceServer) UpdateKennel(context.Context, *Kennel) (*Kennel, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateKennel not implemented")
}
func (UnimplementedKennelServiceServer) mustEmbedUnimplementedKennelServiceServer() {}

// UnsafeKennelServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KennelServiceServer will
// result in compilation errors.
type UnsafeKennelServiceServer interface {
	mustEmbedUnimplementedKennelServiceServer()
}

func RegisterKennelServiceServer(s grpc.ServiceRegistrar, srv KennelServiceServer) {
	s.RegisterService(&KennelService_ServiceDesc, srv)
}

func _KennelService_GetAllKennels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KennelServiceServer).GetAllKennels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiservice.KennelService/GetAllKennels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KennelServiceServer).GetAllKennels(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KennelService_GetKennelById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KennelID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KennelServiceServer).GetKennelById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiservice.KennelService/GetKennelById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KennelServiceServer).GetKennelById(ctx, req.(*KennelID))
	}
	return interceptor(ctx, in, info, handler)
}

func _KennelService_CreateKennel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateKennelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KennelServiceServer).CreateKennel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiservice.KennelService/CreateKennel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KennelServiceServer).CreateKennel(ctx, req.(*CreateKennelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KennelService_DeleteKennel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KennelID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KennelServiceServer).DeleteKennel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiservice.KennelService/DeleteKennel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KennelServiceServer).DeleteKennel(ctx, req.(*KennelID))
	}
	return interceptor(ctx, in, info, handler)
}

func _KennelService_UpdateKennel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Kennel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KennelServiceServer).UpdateKennel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiservice.KennelService/UpdateKennel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KennelServiceServer).UpdateKennel(ctx, req.(*Kennel))
	}
	return interceptor(ctx, in, info, handler)
}

// KennelService_ServiceDesc is the grpc.ServiceDesc for KennelService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KennelService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "apiservice.KennelService",
	HandlerType: (*KennelServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllKennels",
			Handler:    _KennelService_GetAllKennels_Handler,
		},
		{
			MethodName: "GetKennelById",
			Handler:    _KennelService_GetKennelById_Handler,
		},
		{
			MethodName: "CreateKennel",
			Handler:    _KennelService_CreateKennel_Handler,
		},
		{
			MethodName: "DeleteKennel",
			Handler:    _KennelService_DeleteKennel_Handler,
		},
		{
			MethodName: "UpdateKennel",
			Handler:    _KennelService_UpdateKennel_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc_services.proto",
}

// BreedServiceClient is the client API for BreedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BreedServiceClient interface {
	// Create Breed Service
	//
	// This service will recieve a CreateBreedRequest object and will return a Breed object
	CreateBreed(ctx context.Context, in *CreateBreedRequest, opts ...grpc.CallOption) (*Breed, error)
	// Get All Breed Service
	//
	// This service will recieve an EmptyRequest and will return a list with all breeds registered
	GetAllBreed(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*GetAllBreedResponse, error)
	// Get Breed By Id
	//
	// This service will recieve a BreedID as argument and will return a Breed based on the given ID
	GetBreedById(ctx context.Context, in *BreedID, opts ...grpc.CallOption) (*Breed, error)
	// Delete Breed
	//
	// This service will recieve a BreedID as argument and will return a Breed based on the given ID
	DeleteBreed(ctx context.Context, in *BreedID, opts ...grpc.CallOption) (*Breed, error)
	// Update Breed
	//
	// This service will recieve a Breed object as argument and will return the same updated breed object
	UpdateBreed(ctx context.Context, in *Breed, opts ...grpc.CallOption) (*Breed, error)
}

type breedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBreedServiceClient(cc grpc.ClientConnInterface) BreedServiceClient {
	return &breedServiceClient{cc}
}

func (c *breedServiceClient) CreateBreed(ctx context.Context, in *CreateBreedRequest, opts ...grpc.CallOption) (*Breed, error) {
	out := new(Breed)
	err := c.cc.Invoke(ctx, "/apiservice.BreedService/CreateBreed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *breedServiceClient) GetAllBreed(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*GetAllBreedResponse, error) {
	out := new(GetAllBreedResponse)
	err := c.cc.Invoke(ctx, "/apiservice.BreedService/GetAllBreed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *breedServiceClient) GetBreedById(ctx context.Context, in *BreedID, opts ...grpc.CallOption) (*Breed, error) {
	out := new(Breed)
	err := c.cc.Invoke(ctx, "/apiservice.BreedService/GetBreedById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *breedServiceClient) DeleteBreed(ctx context.Context, in *BreedID, opts ...grpc.CallOption) (*Breed, error) {
	out := new(Breed)
	err := c.cc.Invoke(ctx, "/apiservice.BreedService/DeleteBreed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *breedServiceClient) UpdateBreed(ctx context.Context, in *Breed, opts ...grpc.CallOption) (*Breed, error) {
	out := new(Breed)
	err := c.cc.Invoke(ctx, "/apiservice.BreedService/UpdateBreed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BreedServiceServer is the server API for BreedService service.
// All implementations must embed UnimplementedBreedServiceServer
// for forward compatibility
type BreedServiceServer interface {
	// Create Breed Service
	//
	// This service will recieve a CreateBreedRequest object and will return a Breed object
	CreateBreed(context.Context, *CreateBreedRequest) (*Breed, error)
	// Get All Breed Service
	//
	// This service will recieve an EmptyRequest and will return a list with all breeds registered
	GetAllBreed(context.Context, *EmptyRequest) (*GetAllBreedResponse, error)
	// Get Breed By Id
	//
	// This service will recieve a BreedID as argument and will return a Breed based on the given ID
	GetBreedById(context.Context, *BreedID) (*Breed, error)
	// Delete Breed
	//
	// This service will recieve a BreedID as argument and will return a Breed based on the given ID
	DeleteBreed(context.Context, *BreedID) (*Breed, error)
	// Update Breed
	//
	// This service will recieve a Breed object as argument and will return the same updated breed object
	UpdateBreed(context.Context, *Breed) (*Breed, error)
	mustEmbedUnimplementedBreedServiceServer()
}

// UnimplementedBreedServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBreedServiceServer struct {
}

func (UnimplementedBreedServiceServer) CreateBreed(context.Context, *CreateBreedRequest) (*Breed, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBreed not implemented")
}
func (UnimplementedBreedServiceServer) GetAllBreed(context.Context, *EmptyRequest) (*GetAllBreedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllBreed not implemented")
}
func (UnimplementedBreedServiceServer) GetBreedById(context.Context, *BreedID) (*Breed, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBreedById not implemented")
}
func (UnimplementedBreedServiceServer) DeleteBreed(context.Context, *BreedID) (*Breed, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBreed not implemented")
}
func (UnimplementedBreedServiceServer) UpdateBreed(context.Context, *Breed) (*Breed, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBreed not implemented")
}
func (UnimplementedBreedServiceServer) mustEmbedUnimplementedBreedServiceServer() {}

// UnsafeBreedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BreedServiceServer will
// result in compilation errors.
type UnsafeBreedServiceServer interface {
	mustEmbedUnimplementedBreedServiceServer()
}

func RegisterBreedServiceServer(s grpc.ServiceRegistrar, srv BreedServiceServer) {
	s.RegisterService(&BreedService_ServiceDesc, srv)
}

func _BreedService_CreateBreed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBreedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BreedServiceServer).CreateBreed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiservice.BreedService/CreateBreed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BreedServiceServer).CreateBreed(ctx, req.(*CreateBreedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BreedService_GetAllBreed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BreedServiceServer).GetAllBreed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiservice.BreedService/GetAllBreed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BreedServiceServer).GetAllBreed(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BreedService_GetBreedById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BreedID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BreedServiceServer).GetBreedById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiservice.BreedService/GetBreedById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BreedServiceServer).GetBreedById(ctx, req.(*BreedID))
	}
	return interceptor(ctx, in, info, handler)
}

func _BreedService_DeleteBreed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BreedID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BreedServiceServer).DeleteBreed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiservice.BreedService/DeleteBreed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BreedServiceServer).DeleteBreed(ctx, req.(*BreedID))
	}
	return interceptor(ctx, in, info, handler)
}

func _BreedService_UpdateBreed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Breed)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BreedServiceServer).UpdateBreed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiservice.BreedService/UpdateBreed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BreedServiceServer).UpdateBreed(ctx, req.(*Breed))
	}
	return interceptor(ctx, in, info, handler)
}

// BreedService_ServiceDesc is the grpc.ServiceDesc for BreedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BreedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "apiservice.BreedService",
	HandlerType: (*BreedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateBreed",
			Handler:    _BreedService_CreateBreed_Handler,
		},
		{
			MethodName: "GetAllBreed",
			Handler:    _BreedService_GetAllBreed_Handler,
		},
		{
			MethodName: "GetBreedById",
			Handler:    _BreedService_GetBreedById_Handler,
		},
		{
			MethodName: "DeleteBreed",
			Handler:    _BreedService_DeleteBreed_Handler,
		},
		{
			MethodName: "UpdateBreed",
			Handler:    _BreedService_UpdateBreed_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc_services.proto",
}

// MatchServiceClient is the client API for MatchService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MatchServiceClient interface {
	MatchUserWithDog(ctx context.Context, in *UserID, opts ...grpc.CallOption) (*Dog, error)
}

type matchServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMatchServiceClient(cc grpc.ClientConnInterface) MatchServiceClient {
	return &matchServiceClient{cc}
}

func (c *matchServiceClient) MatchUserWithDog(ctx context.Context, in *UserID, opts ...grpc.CallOption) (*Dog, error) {
	out := new(Dog)
	err := c.cc.Invoke(ctx, "/apiservice.MatchService/MatchUserWithDog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MatchServiceServer is the server API for MatchService service.
// All implementations must embed UnimplementedMatchServiceServer
// for forward compatibility
type MatchServiceServer interface {
	MatchUserWithDog(context.Context, *UserID) (*Dog, error)
	mustEmbedUnimplementedMatchServiceServer()
}

// UnimplementedMatchServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMatchServiceServer struct {
}

func (UnimplementedMatchServiceServer) MatchUserWithDog(context.Context, *UserID) (*Dog, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MatchUserWithDog not implemented")
}
func (UnimplementedMatchServiceServer) mustEmbedUnimplementedMatchServiceServer() {}

// UnsafeMatchServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MatchServiceServer will
// result in compilation errors.
type UnsafeMatchServiceServer interface {
	mustEmbedUnimplementedMatchServiceServer()
}

func RegisterMatchServiceServer(s grpc.ServiceRegistrar, srv MatchServiceServer) {
	s.RegisterService(&MatchService_ServiceDesc, srv)
}

func _MatchService_MatchUserWithDog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchServiceServer).MatchUserWithDog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiservice.MatchService/MatchUserWithDog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchServiceServer).MatchUserWithDog(ctx, req.(*UserID))
	}
	return interceptor(ctx, in, info, handler)
}

// MatchService_ServiceDesc is the grpc.ServiceDesc for MatchService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MatchService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "apiservice.MatchService",
	HandlerType: (*MatchServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MatchUserWithDog",
			Handler:    _MatchService_MatchUserWithDog_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc_services.proto",
}
